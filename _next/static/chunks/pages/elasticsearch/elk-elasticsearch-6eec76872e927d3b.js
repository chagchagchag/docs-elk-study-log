(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[802],{5353:function(e,n,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/elasticsearch/elk-elasticsearch",function(){return s(143)}])},143:function(e,n,s){"use strict";s.r(n),s.d(n,{__toc:function(){return g},default:function(){return b}});var i=s(5893),r=s(2673),l=s(373),c=s(8426);s(9128);var d=s(2643),h={src:"/docs-elk-study-log/_next/static/media/1.b98c6f5c.png",height:432,width:563,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAAAAADbboAnAAAAM0lEQVR42jXGQQ4AERREwb7/SSezIQi+0M9KrUrmDGzL7P5SsBHMHGDFWH21jf4a30mZC/ymLvWRBMktAAAAAElFTkSuQmCC",blurWidth:8,blurHeight:6},a={src:"/docs-elk-study-log/_next/static/media/6.5e28ba3c.png",height:234,width:565,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAAP0lEQVR42h3LsQ0AMQhDURwaEPvvxxRI3CEIyi/cPBnuHhHdXVWqysyZaWb4XkS0LCJrM0ME/K9zzp52ASwAuFgcJn472dumAAAAAElFTkSuQmCC",blurWidth:8,blurHeight:3},t={src:"/docs-elk-study-log/_next/static/media/7.700b7a4a.png",height:308,width:1066,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAACCAIAAADq9gq6AAAAMklEQVR42g3JQRYAIAQFwL7E/c9pX6/wZLaDzATg7mb27qYpqso8EREdVRXND8CyaJB8pToXtNwYJ9kAAAAASUVORK5CYII=",blurWidth:8,blurHeight:2},x={src:"/docs-elk-study-log/_next/static/media/8.3b25c6f9.png",height:570,width:450,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAICAIAAABVpBlvAAAAdElEQVR42iXKSw7DIAxFUfa/v8Cgs0pUFVKo+NkY29CQ3OF5z6y1QgjWWufccRzeezPnLHeIEOPZO25qDTvJdW/QRadhlpq/VN+Mn3S+CKMRUWgJ4SdccwqDwKgq9quhOmsFFt0Ed6pSSmbmTUQ0xng2EfkDc/KJxWXvKpQAAAAASUVORK5CYII=",blurWidth:6,blurHeight:8},j={src:"/docs-elk-study-log/_next/static/media/2.047d7a97.png",height:434,width:1017,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAAAAACLoxGUAAAAI0lEQVR42mP49ePXt++/vv9i+PT5w6fPHz99Zvjy5TMIfQUAN0MW9E3kYA0AAAAASUVORK5CYII=",blurWidth:8,blurHeight:3},A={src:"/docs-elk-study-log/_next/static/media/3.e1f4031f.png",height:321,width:965,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAATElEQVR42g3JWwqAIBAFUPe/wYqIoJ8IshybOw81qfN7AtKCvLfWmdlLL+VlWK013MfwB6BESdJE5/zEUdQDxBlqZgAori5nvjYR/QACW0QknTZgzAAAAABJRU5ErkJggg==",blurWidth:8,blurHeight:3},o={src:"/docs-elk-study-log/_next/static/media/4.af21933b.png",height:321,width:967,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAAUUlEQVR42h3LMQ6AIAwAQP7/HUYfwObAaiRM2hhjsZQiVqMJt58RAAnhQSwit37tooxR9TXoXLGWvU/MkibaRloHqWoYIMfY+jj3udWDcClSf7hUQl/ZydlCAAAAAElFTkSuQmCC",blurWidth:8,blurHeight:3},p={src:"/docs-elk-study-log/_next/static/media/5.a76d97c3.png",height:321,width:1103,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAACCAIAAADq9gq6AAAAOElEQVR42gUAOQ4AEMz/P6eLSAcbEqR11BWTKEG8AK9yoO5TkgI2Tpe3GohT68ONOXZyoxhqss77OrsrmvkrEjAAAAAASUVORK5CYII=",blurWidth:8,blurHeight:2};let g=[{depth:2,value:"Elasticsearch 설치, 예제",id:"elasticsearch-설치-예제"},{depth:2,value:"ELK 스택 설치",id:"elk-스택-설치"},{depth:2,value:"Elasticsearch",id:"elasticsearch"},{depth:2,value:"Elasticsearch 구성",id:"elasticsearch-구성"},{depth:2,value:"관계형 데이터베이스와 비교",id:"관계형-데이터베이스와-비교"},{depth:2,value:"Elasticsearch 의 단점",id:"elasticsearch-의-단점"},{depth:2,value:"Indexing (색인, 인덱싱)",id:"indexing-색인-인덱싱"},{depth:2,value:"Full Text Search (전문 검색)",id:"full-text-search-전문-검색"},{depth:2,value:"Inverted Index",id:"inverted-index"},{depth:3,value:"e.g. 게시판 글 검색",id:"eg-게시판-글-검색"},{depth:2,value:"Cluster, Node, Index, Shard",id:"cluster-node-index-shard"},{depth:2,value:"Shard, Primary Shard, Replica Shard",id:"shard-primary-shard-replica-shard"},{depth:2,value:"마스터 노드, 데이터 노드, 코디네이팅 노드, 인제스트 노드",id:"마스터-노드-데이터-노드-코디네이팅-노드-인제스트-노드"},{depth:2,value:"Split Brain (todo)",id:"split-brain-todo"},{depth:2,value:"Opensearch vs AWS Opensearch vs Elasticsearch",id:"opensearch-vs-aws-opensearch-vs-elasticsearch"},{depth:3,value:"Opensearch",id:"opensearch"},{depth:3,value:"AWS Opensearch",id:"aws-opensearch"},{depth:3,value:"Elasticsearch",id:"elasticsearch-1"},{depth:2,value:"Aggregation",id:"aggregation"},{depth:2,value:"Cache",id:"cache"},{depth:3,value:"Shart Request Cache",id:"shart-request-cache"},{depth:3,value:"Field Data Cache",id:"field-data-cache"},{depth:2,value:"Metrics, Bucket Aggregation",id:"metrics-bucket-aggregation"},{depth:3,value:"Metric Aggregation",id:"metric-aggregation"},{depth:3,value:"Bucket Aggregation",id:"bucket-aggregation"},{depth:2,value:"Mapping",id:"mapping"}];function _createMdxContent(e){let n=Object.assign({h2:"h2",ul:"ul",li:"li",a:"a",code:"code",p:"p",img:"img",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",h3:"h3",blockquote:"blockquote"},(0,d.a)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"elasticsearch-설치-예제",children:"Elasticsearch 설치, 예제"}),"\n",(0,i.jsx)(n.h2,{id:"elk-스택-설치",children:"ELK 스택 설치"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/deviantony/docker-elk",children:"github.com/deviantony/docker-elk"})," 을 clone"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".env"})," 파일 내의 주요 패스워드 들 수정","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"비밀번호는 8자?이상이어야 에러가 나지 않습니다."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["docker-compose up setup","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"setup-1 exited with code 0 이라는 메시지가 뜨면 정상설치 된 것 입니다."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"docker-compose up -d"}),"\n",(0,i.jsxs)(n.li,{children:["kibana 는 ",(0,i.jsx)(n.a,{href:"http://localhost:5601",children:"http://localhost:5601"})," 로 접속 가능하며, user, password 는 아래와 같이 입력합니다.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"user : elastic"}),"\n",(0,i.jsxs)(n.li,{children:["password : ",(0,i.jsx)(n.code,{children:".env"})," 파일 내에 입력한 패스워드"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"elasticsearch",children:"Elasticsearch"}),"\n",(0,i.jsxs)(n.p,{children:["Elasticsearch CRUD 는 REST API 를 활용합니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.p,{children:["REST API 로 할 수 있는 작업들은 아래와 같습니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"클러스터, 노드, 색인(Index)의 상태 또는 통계를 확인 가능합니다."}),"\n",(0,i.jsx)(n.li,{children:"클러스터, 노드, 색인(Index)의 데이터,메타데이터 관리"}),"\n",(0,i.jsx)(n.li,{children:"CRUD(Create, Read, Update, Delete) 수행"}),"\n",(0,i.jsx)(n.li,{children:"인덱스 검색 작업"}),"\n",(0,i.jsx)(n.li,{children:"페이징, 정렬, 필터링, 스크립팅, 집계 및 기타 고급작업"}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"elasticsearch-구성",children:"Elasticsearch 구성"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{placeholder:"blur",src:h})}),"\n",(0,i.jsx)(n.p,{children:"도큐먼트"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"단일 데이터 단위를 Document 라고 부릅니다."}),"\n",(0,i.jsx)(n.li,{children:"데이터가 저장되는 최소단위이며, 하나의 문서는 다수의 필드로 구성됩니다."}),"\n",(0,i.jsx)(n.li,{children:"nested 구조를 지원합니다."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"인덱스"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Document 의 집합을 인덱스라고 부릅니다."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"ES 에 데이터를 저장하는 것은 인덱싱이라고 부릅니다."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"인덱스 명으로 문서를 검색합니다."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"분산환경에서는 인덱스는 여러 노드에 분산되어 저장됩니다."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"타입"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"인덱스의 논리적 구조를 의미합니다."}),"\n",(0,i.jsx)(n.li,{children:"7.0 버전부터 인덱스당 하나의 타입을 제공하며, Index 는 Type 과 동일시 되는 개념이 되었습니다."}),"\n",(0,i.jsx)(n.li,{children:"아마도 7.0 부터는 타입 대신 인덱스라는 단어만 사용할 것으로 보임"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"필드"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"문서를 구성하는 속성 입니다."}),"\n",(0,i.jsx)(n.li,{children:"Column 과 비슷한 개념입니다. 하나의 필드는 여러 데이터 타입(keyword, text)을 가질 수 있습니다."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"매핑"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"데이터의 저장형태, 검색을 위해 데이터를 어떻게 접근,처리할 지를 의미하는 개념입니다."}),"\n",(0,i.jsx)(n.li,{children:"문서의 필드, 필드의 속성, 인덱싱 방법을 정의합니다."}),"\n",(0,i.jsx)(n.li,{children:"인덱스 매핑에서는 여러 데이터 타입이 지정가능하지만, 필드 명은 중복사용 불가합니다."}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"관계형-데이터베이스와-비교",children:"관계형 데이터베이스와 비교"}),"\n",(0,i.jsx)(n.p,{children:"관계형 데이터베이스의 데이터베이스 같은 개념은 일라스틱서치에서는 인덱스를 의미합니다. 관계형 데이터베이스의 테이블과 같은 개념은 일라스틱서치에서는 타입을 의미합니다."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{align:"center",children:"Elasticsearch"}),(0,i.jsx)(n.th,{align:"center",children:"관계형 데이터베이스"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{align:"center",children:"인덱스 (Index)"}),(0,i.jsx)(n.td,{align:"center",children:"데이터베이스"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{align:"center",children:"샤드 (Shard)"}),(0,i.jsx)(n.td,{align:"center",children:"파티션"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{align:"center",children:"타입 (Type)"}),(0,i.jsx)(n.td,{align:"center",children:"테이블"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{align:"center",children:"문서 (Document)"}),(0,i.jsx)(n.td,{align:"center",children:"행"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{align:"center",children:"필드 (Field)"}),(0,i.jsx)(n.td,{align:"center",children:"열"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{align:"center",children:"매핑 (Mapping)"}),(0,i.jsx)(n.td,{align:"center",children:"스키마"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{align:"center",children:"QueryDSL"}),(0,i.jsx)(n.td,{align:"center",children:"SQL"})]})]})]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsxs)(n.p,{children:["Elasticsearch 는 검색에 특화된 저장소이며 관계형 데이터베이스와는 목적이 조금 다릅니다. 관계형 데이터베이스는 정규화 등을 통해 데이터의 중복을 제거해 논리적이며 일관적인 데이터의 저장이 목적입니다. 반면 Elasticsearch 의 경우 검색/통계에 특화된 저장소입니다. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.p,{children:["관계형 데이터베이스에서는 SQL로 원하는 정보를 검색하는게 가능하지만, 단순한 검색이지만, Elasticsearch 는 비정형 데이터를 Indexing 을 통해서 검색이 가능하며, 형태소 분석, 역색인을 통해 빠른 검색이 가능합니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(n.h2,{id:"elasticsearch-의-단점",children:"Elasticsearch 의 단점"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Near Real Time (NRT) : 실시간이 아닙니다. 인덱싱된 데이터는 1초 뒤에 검색이 가능합니다."}),"\n",(0,i.jsx)(n.li,{children:"트랜잭션, 롤백 불가 : 리소스 소모가 큰 롤백이나 트랜잭션은 지원하지 않습니다."}),"\n",(0,i.jsx)(n.li,{children:"데이터 업데이트 불가 : 기존 문서를 삭제 후 변경내용으로 새로운 문서를 생성하는 reindexing 방식이기에 비용이 큽니다."}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"indexing-색인-인덱싱",children:"Indexing (색인, 인덱싱)"}),"\n",(0,i.jsxs)(n.p,{children:["데이터가 인덱스 내에 도큐먼트로 저장될 때 그 데이터를 토큰들로 분해한 후 저장하는 과정을 의미합니다. 한국어로는 색인이라는 말을 자주 씁니다. 한국어로 치환한 단어가 조금 더 이질감이 느껴지지만, 자주 접하게 되는 단어이기에 알아두는 것이 좋습니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"full-text-search-전문-검색",children:"Full Text Search (전문 검색)"}),"\n",(0,i.jsxs)(n.p,{children:["텍스트 전체를 색인해서 특정 단어가 포함된 문서를 검색하는 것을 의미하며, Elasticsearch 에서 제공하는 다양한 플러그인을 조합해서 더 빠른 검색이 가능합니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(n.h2,{id:"inverted-index",children:"Inverted Index"}),"\n",(0,i.jsxs)(n.p,{children:["역색인을 의미합니다. Inverted Index 를 이용하면 인덱스 내에서 검색을 원하는 단어가 포함된 모든 문서의 위치를 검색 가능합니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.p,{children:["Elasticsearch 의 검색이 빠른 이유는 Inverted Index 때문입니다. 관계형 데이터베이스는 모든 문서의 내용을 읽어서 검색하고 있는 키워드가 있는지 검색합니다. 따라서 연산 시에 자원소모가 크며 Elasticsearch 에 비해서는 검색에 있어서는 비효율 적입니다. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.p,{children:["Inverted Index 는 특정 Term 을 포함하고 있는 문서에 대한 인덱스 테이블을 만든 것을 의미합니다. Elasticsearch 는 이 인덱스 테이블에서 검색을 하기 때문에 검색 속도가 빠릅니다. 문서가 수천만건이 넘어가더라도 빠르게 검색이 가능합니다. 따라서 '검색'만을 위한 기능에 최적화되어 있습니다. 다만 자주 등장하는 단어 (a, the, and 등)은 오히려 느려질 수 있다는 단점이 있습니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.p,{children:["이 경우 Stop Words 설정을 통해 인덱스에서 제거하고 검색어에 등장해도 무시하는 것이 가능합니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.p,{children:["이 외에도 삽입/삭제/업데이트 시에 저장소에 오버헤드가 발생합니다. 예를 들면 여행사의 상품인덱스의 경우 상품하나 추가 시에 1시간이 넘게 소요되는 경우도 있다고 전해들은 경험이 있습니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h3,{id:"eg-게시판-글-검색",children:"e.g. 게시판 글 검색"}),"\n",(0,i.jsx)(n.p,{children:"게시판 서비스를 만들었고 현재 관계형 데이터베이스에는 아래와 같이 저장되어 있다고 하겠습니다."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{placeholder:"blur",src:a})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsxs)(n.p,{children:["그리고 위의 데이터베이스에서 '송중기'라는 데이터가 포함된 모든 행을 찾아보겠습니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(n.p,{children:"관계형 데이터베이스의 경우 순차적으로 탐색을 하게 되고 결국 아래와 같이 데이터를 처음부터 끝까지 순회를 하면서 '송중기' 라는 단어가 포함된 행을 찾습니다."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{placeholder:"blur",src:t})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.p,{children:"이번에는 Elasticsearch 에서 '송중기'라는 단어가 포함된 문서를 모두 찾아보겠습니다."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{placeholder:"blur",src:x})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsxs)(n.p,{children:["'송중기' 라는 단어에 대해 미리 Inverted Indexing 작업을 해둔 상태이기 때문에 doc3, doc4 에 '송중기'에 관련된 게시글이 있다는 사실을 알았습니다. 이제 이 doc3, doc4 에 있는 생성시각, 작성자, 게시글 본문, 제목 을 애플리케이션 레벨에서 매핑해서 리턴해주면 됩니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.p,{children:["서비스가 커져서 관계형 데이터베이스만으로 처리하기에는 스케일이 커진 경우 이렇게 일정 부분은 Elasticsearch  또는 빅데이터 시스템의 인프라와 혼용해서 사용할 수 있을 것으로 보입니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"cluster-node-index-shard",children:"Cluster, Node, Index, Shard"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{placeholder:"blur",src:j})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"shard 의 번호들이 어떤 인덱스에 어떤 shard 번호들이 배치되어있고 2개씩 복제되어 있는지 확인해보세요."}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.p,{children:"Cluster"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"노드의 집합입니다. 노드 들을 관리하며 색인화, 검색 기능을 Cluster 레벨에서 제공합니다."}),"\n",(0,i.jsx)(n.li,{children:"Cluster 는 고유한 이름을 가지며, 이름이 다른 Cluster 들을 여러개 두는 것 역시 가능합니다."}),"\n",(0,i.jsx)(n.li,{children:"Cluster 를 Node 1기로만 구성하는 것 역시 가능합니다."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Node"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Elasticsearch 내의 개별 노드를 의미합니다."}),"\n",(0,i.jsx)(n.li,{children:"데이터 저장, 클러스터가 개별 노드들을 이용해서 노드에 indexing, 검색을 수행하게끔 합니다."}),"\n",(0,i.jsx)(n.li,{children:"Node 에도 고유한 이름이 부여되며, 기본값은 UUID 방식으로 지정됩니다."}),"\n",(0,i.jsx)(n.li,{children:"클러스터 이름을 지정해서 특정 클러스터에 소속되게끔 지정하는 것 역시 가능합니다."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Index"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Document 를 모아두는 곳을 Index 라고 합니다. 관계형 데이터베이스에서 데이터베이스에 해당하는 개념이 Index 입니다."}),"\n",(0,i.jsx)(n.li,{children:"Elasticsearch 에 데이터를 저장하는 것을 Indexing (인덱싱) 이라고 부릅니다."}),"\n",(0,i.jsx)(n.li,{children:"Elasticsearch"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Shard"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"인덱스는 하나 이상의 샤드단위로 분산해서 저장하는 것이 가능합니다."}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"shard-primary-shard-replica-shard",children:"Shard, Primary Shard, Replica Shard"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{placeholder:"blur",src:A})}),"\n",(0,i.jsxs)(n.p,{children:["Index 는 하나 이상의 Shard 로 분리할 수 있고, 데이터를 Shard 단위로 분산해서 저장할 수 있습니다. 카프카의 토픽을 파티션 단위로 나누는 것과 유사한 개념입니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.p,{children:["각각의 Node 에는 Primary Shard 와 Replica Shard 를 둘 수 있습니다. Replica Shard 는 장애 상황에 대비하기 위해 Primary Shard 의 복제본으로 두는 Shard 입니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{placeholder:"blur",src:o})}),"\n",(0,i.jsxs)(n.p,{children:["만약 Node 0 번에 장애가 나면, Node 0 에 있는 Primary Shard 인 Shard 0 은 사용할 수 없게 됩니다. 이 경우 Node 2 에 복제를 해둔 Replica Shard 중 Shard 0을 Primary Shard 가 되도록 지정됩니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{placeholder:"blur",src:p})}),"\n",(0,i.jsxs)(n.p,{children:["장애가 난 Node 0 번이 복구가 되기를 기다려도 복구가 되지 않을 경우 Node 0 의 레플리카 샤드 들을 다른 노드 들로 복제하는 작업이 수행됩니다. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.p,{children:["운영을 위해 미리 설정해둔 샤드의 개수가 있는데, 장애가 난 Node 로 인해 레플리카 갯수가 일정 시간 동안 유지되지 않으므로 장애가 나지 않은 다른 노드의 레플리캬 샤드 들을 복제하게 됩니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(n.h2,{id:"마스터-노드-데이터-노드-코디네이팅-노드-인제스트-노드",children:"마스터 노드, 데이터 노드, 코디네이팅 노드, 인제스트 노드"}),"\n",(0,i.jsx)(n.p,{children:"마스터 노드"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"마스터 노드는 클러스터 상태 정보를 관리합니다. 지연이 없고 네트워크 가용성(Availability)가 좋은 노드를 마스터 노드로 선택합니다."}),"\n",(0,i.jsx)(n.li,{children:"클러스터를 노드 1기로 구성하면 1기의 노드가 마스터 노드가 됩니다."}),"\n",(0,i.jsx)(n.li,{children:"마스터 노드 다운시 다른 마스터 후보 노드 중 하나가 마스터 노드로 선출됩니다."}),"\n",(0,i.jsx)(n.li,{children:"마스터 후보 노드 들은 node.data:false 로 설정해서 노드 역할만 하며, 데이터는 저장하지 않도록 지정하는 것 역시 가능합니다."}),"\n",(0,i.jsx)(n.li,{children:"마스터 후보 노드 (master eligible) 들은 마스터 노드의 정보들을 공유하고 있으며 즉시 마스터 역할을 수행 가능합니다. 노드, 샤드의 갯수가 많은 상황이면 일부 노드만 마스터 노드 옵션을 true, 나머지는 false 로 설정해서 부하를 줄이는 편입니다."}),"\n",(0,i.jsx)(n.li,{children:"최소 마스터 대수 설정에 관련된 내용도 있는데 여기에 대해서는 Split Brain 에서 정리합니다."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"데이터 노드"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"도큐먼트가 저장되는 노드입니다."}),"\n",(0,i.jsx)(n.li,{children:"인덱싱 작업에 리소스가 많이 소모되는 노드이며, 리소스를 모니터링하는 것이 필요합니다."}),"\n",(0,i.jsx)(n.li,{children:"운영환경에서는 마스터 노드와 데이터 노드를 분리하는 것이 권장되며, 인덱싱할 도큐먼트가 적다면 굳이 분리하지 않아도 됩니다."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"코디네이팅 노드"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"들어온 요청을 분산시켜주는 노드입니다."}),"\n",(0,i.jsx)(n.li,{children:"라운드 로빈 방식입니다."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"인제스트 노드"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Indexing(색인) 전에 데이터를 전처리하는 노드 입니다."}),"\n",(0,i.jsx)(n.li,{children:"데이터 포맷 변경을 위해 스크립트로 파이프라인을 구성하기도 합니다."}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"split-brain-todo",children:"Split Brain (todo)"}),"\n",(0,i.jsxs)(n.p,{children:["마스터 후보 노드 사이에 네트워크가 단절 되었을 때 마스터 후보 노드 각각은 마스터로 승격됩니다. 이렇게 되면 클러스터가 두개가 되어서 독립적인 클러스터 두개로 동작하게 되는 현상이 발생합니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.p,{children:["이렇게해서 발생한 독립적인 클러스터 두개는 클러스터 마다 각각 독립적으로 데이터 쓰기, 업데이트가 발생하는 문제가 생기고, 개별 클러스터에 존재하는 마스터 노드로 인해 데이터가 동기화되지 않는 문제가 있습니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(n.p,{children:"여기에 대한 해결 방법들은 아래와 같습니다."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["discovery.zen.minimum_master_nodes 옵션을 아래와 같이 설정해줍니다.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"(master_eligible_nodes/2) + 1"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"마스터 노드 후보 갯수를 홀수로 지정"}),"\n",(0,i.jsxs)(n.li,{children:["split brain 발생 후 네트워크 복구 시 투표를 통해 두기의 클러스터 중 하나를 선택 후 선택된 클러스터를 기준으로 데이터를 맞춥니다.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"이 부분에 대해서는 조금 더 자료를 찾아본 후 정리를 하겠습니다."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"opensearch-vs-aws-opensearch-vs-elasticsearch",children:"Opensearch vs AWS Opensearch vs Elasticsearch"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.elastic.co/kr/amazon-opensearch-service",children:"https://www.elastic.co/kr/amazon-opensearch-service"})}),"\n",(0,i.jsx)(n.h3,{id:"opensearch",children:"Opensearch"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"AWS 에서 Elasticsearch, Kibana 의 ALv2(Apache License 2.0) 오픈소스를 fork 한 것을 Opensearch 라고 명명했습니다."}),"\n",(0,i.jsx)(n.li,{children:"Elasticsearch 의 대부분의 기능을 사용 가능합니다."}),"\n",(0,i.jsx)(n.li,{children:"100% 오픈소스이며, 현재는 Opensearch 에서 자체 개발 및 업데이트를 진행합니다."}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://aws.amazon.com/ko/what-is/opensearch/",children:"https://aws.amazon.com/ko/what-is/opensearch/"})}),"\n",(0,i.jsx)(n.li,{children:"Elasticsearch 7.10 이후의 Elasticsearch 버전은 오픈소스가 아니며, ALV2 라이선스로 배포되지 않아서 Amazon Opensearch Service 는 Elasticsearh 7.10 까지만 지원됩니다."}),"\n",(0,i.jsx)(n.li,{children:"Elasticsearch 7.10 이후 부터는 Amazon 에서 관리하는 오픈소스 Opensearch 의 버전으로 기능들을 제공하게 되었습니다."}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h3,{id:"aws-opensearch",children:"AWS Opensearch"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"AWS Opensearch 는 AWS 에서 제공하는 매니지드 Opensearch 이며, AWS 에서 클러스터 관리를 알아서 해주지만 내장된 플러그인만 사용가능하다는 단점 존재합니다."}),"\n",(0,i.jsx)(n.li,{children:"Opensearch 는 es 에 등록되지 않은 플러그인들을 설치할 수 있습니다."}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://aws.amazon.com/ko/opensearch-service/getting-started/",children:"https://aws.amazon.com/ko/opensearch-service/getting-started/"})}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h3,{id:"elasticsearch-1",children:"Elasticsearch"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"2021년 1월 Elastic 은 소프트웨어 라이센스 전략을 변경했는데, Elasticsearch 및 Kibana 의 새 버전을 출시하지 않겠다고 발표했습니다."}),"\n",(0,i.jsx)(n.li,{children:"Elasticsearch 7.10 까지만 ALv2 로 오픈소스"}),"\n",(0,i.jsx)(n.li,{children:"Elasticsearch 7.10 이후의 버전은 유료 서비스"}),"\n",(0,i.jsx)(n.li,{children:"설치해서 사용은 가능하지만 추가 기능을 사용하기 위해서는 라이센스 구매가 필수적입니다."}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"aggregation",children:"Aggregation"}),"\n",(0,i.jsx)(n.h2,{id:"cache",children:"Cache"}),"\n",(0,i.jsx)(n.h3,{id:"shart-request-cache",children:"Shart Request Cache"}),"\n",(0,i.jsx)(n.h3,{id:"field-data-cache",children:"Field Data Cache"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"metrics-bucket-aggregation",children:"Metrics, Bucket Aggregation"}),"\n",(0,i.jsx)(n.h3,{id:"metric-aggregation",children:"Metric Aggregation"}),"\n",(0,i.jsx)(n.h3,{id:"bucket-aggregation",children:"Bucket Aggregation"}),"\n",(0,i.jsx)(n.h2,{id:"mapping",children:"Mapping"})]})}let u={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.a)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(_createMdxContent,{...e})}):_createMdxContent(e)},pageOpts:{filePath:"pages/elasticsearch/elk-elasticsearch.mdx",route:"/elasticsearch/elk-elasticsearch",timestamp:1717236663e3,pageMap:[{kind:"Folder",name:"elasticsearch",route:"/elasticsearch",children:[{kind:"MdxPage",name:"document-api",route:"/elasticsearch/document-api"},{kind:"MdxPage",name:"elk-elasticsearch",route:"/elasticsearch/elk-elasticsearch"},{kind:"Meta",data:{"elk-elasticsearch":"Elasticsearch","document-api":"Document API"}}]},{kind:"MdxPage",name:"index",route:"/"},{kind:"Meta",data:{index:"Introduction",elasticsearch:"Elasticsearch",contact:{title:"Contact ↗",type:"page",href:"-",newWindow:!0}}}],flexsearch:{codeblocks:!0},title:"Elk Elasticsearch",headings:g},pageNextRoute:"/elasticsearch/elk-elasticsearch",nextraLayout:l.ZP,themeConfig:c.Z};var b=(0,r.j)(u)},8426:function(e,n,s){"use strict";var i=s(5893);s(7294);let r={logo:(0,i.jsx)("span",{children:"Docs ELK Study Log"}),project:{link:"https://github.com/chagchagchag/docs-elk-study-log"},docsRepositoryBase:"https://github.com/chagchagchag/docs-elk-study-log",footer:{text:"Nextra Docs Template"}};n.Z=r},5789:function(){}},function(e){e.O(0,[774,796,888,179],function(){return e(e.s=5353)}),_N_E=e.O()}]);